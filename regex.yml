- regex     : '; ?(.+)'
  replace   : '// $1'

- regex     : ' *IF TALENT:TARGET:남자 == 0 && TALENT:PLAYER:남자 == 0\n *TCVAR:TARGET:레즈경험 \+= (\d+)\n *ELSEIF TALENT:TARGET:남자 && TALENT:PLAYER:남자\n *TCVAR:TARGET:BL경험 \+= (\d+)\n *ENDIF'
  replace   : 'add_gay_les_exp_with(target, player, $2, $1);'

- regex     : '%(ABL|TALENT|EX|EXP|MARK|JUEL|PALAM)NAME:(\w+)%'
  replace   : "$2"

- regex     : '%([^%]+)%'
  replace   : "{$1}"

- regex     : '\\@([^\?]+)\?([^#]+)#([^\\@]+)\\@'
  replace   : "{if $1 { @\"$2\" } else { @\"$3\" }}"

# Trim \@\@ string
- regex     : '@" ?(.+?) ?"'
  replace   : '"$1"'

- regex     : 'TOSTR\(([^\)]+)\)'
  replace   : "$1"

- regex     : 'PRINT(FORM)?W (.*)'
  replace   : "ym_print!(r#\"$2\"#, siv, W);"

- regex     : 'PRINT(FORM)?L (.*)'
  replace   : "ym_print!(r#\"$2\"#, siv, L);"

- regex     : 'PRINT(FORM)? (.*)'
  replace   : "ym_print!(r#\"$2\"#, siv);"

- regex     : 'CALLNAME:(\w+)'
  replace   : "$1.call_name"

- regex     : 'NICKNAME:(\w+)'
  replace   : "$1.nick_name"

- regex     : 'MASTERNAME:(\w+)'
  replace   : "$1.master_name"

- regex     : '\bNAME:(\w+)'
  replace   : "$1.name"

- regex     : '조사처리\(([^,]+), "([^"]+)"\)'
  replace   : 'josa("$1", "$2")'

- regex     : 'RETURN 0'
  replace   : 'return false;'

- regex     : 'RETURN 1'
  replace   : 'return true;'

- regex     : '\bASSIPLAY == 0'
  replace   : '!assiplay'

- regex     : '\bASSIPLAY == 1'
  replace   : 'assiplay'

- regex     : 'ASSIPLAY'
  replace   : 'assiplay'

- regex     : 'PLAYER'
  replace   : 'player'

- regex     : 'TARGET'
  replace   : 'target'

- regex     : 'ASSI'
  replace   : 'assi'

- regex     : 'MASTER'
  replace   : 'master'

- regex     : '\bSIF (.+)\n *(.+)'
  replace   : "if $1 { $2 }"

- regex     : '\bIF (.+)'
  replace   : "if $1 {"

- regex     : '\bELSEIF (.+)'
  replace   : "} else if $1 {"

- regex     : '\bELSE'
  replace   : "} else {"

- regex     : '\bENDIF'
  replace   : "}"

- regex     : '\bSOURCE:(\w+):(\w+)'
  replace   : "$1.source[Source::$2]"

- regex     : '\bMARK:(\w+):(\w+)'
  replace   : "$1.mark[Mark::$2]"

- regex     : '\bBASE:(\w+):(\w+)'
  replace   : "$1.base[Base::$2].current"

- regex     : '\bCFLAG:(\w+):(\w+)'
  replace   : "$1.cflag[Cflag::$2]"

- regex     : '\bMAXBASE:(\w+):(\w+)'
  replace   : "$1.base[Base::$2].max"

- regex     : '\bDOWNBASE:(\w+):(\w+)'
  replace   : "$1.down_base[Base::$2]"

- regex     : 'TEQUIP:눈창작기구'
  replace   : 'target.equip.e'

- regex     : 'TEQUIP:입창작기구'
  replace   : 'target.equip.m'


- regex     : 'EQUIP:target:睡眠薬'
  replace   : 'target.equip.drug.contains(DrugEquip::수면제)'

- regex     : '\bTEQUIP:(\w+)'
  replace   : "data.tequip.contains(Tequip::$1)"

- regex     : '\bABL:(\w+):(\w+)'
  replace   : "$1.abl[Abl::$2]"

- regex     : '\bEX:(\w+):(\w+)'
  replace   : "$1.ex[Ex::$2]"

- regex     : '\bEXP:(\w+):(\w+)'
  replace   : "$1.exp[Exp::$2]"

- regex     : '\bUP:(\w+):(\w+)'
  replace   : "$1.up_param[Juel::$2]"

- regex     : '\bPALAM:(\w+):(\w+) >= \(?PALAMLV:(\d)(?: - 1)?\)?'
  replace   : "param_lv($1, Juel::$2) >= $3"

- regex     : '\bPALAM:(\w+):(\w+)'
  replace   : "$1.param[Juel::$2]"

- regex     : '\bJUEL:(\w+):(\w+)'
  replace   : "$1.juel[Juel::$2]"

- regex     : '\b!TALENT:(\w+):(인간|요정|흡혈귀|기계|영체|인형|악마|캇파|요호|반백택|사토리|오니|텐구|구문지|누에|황혼의괴물|신령|반신|사신|선인|강시|둔갑너구리|츠쿠모가미|인어|목분리|늑대인간)'
  replace   : "$1.race != Race::$2"

- regex     : '\bTALENT:(\w+):(인간|요정|흡혈귀|기계|영체|인형|악마|캇파|요호|반백택|사토리|오니|텐구|구문지|누에|황혼의괴물|신령|반신|사신|선인|강시|둔갑너구리|츠쿠모가미|인어|목분리|늑대인간) == 0'
  replace   : "$1.race != Race::$2"

- regex     : '\bTALENT:(\w+):(인간|요정|흡혈귀|기계|영체|인형|악마|캇파|요호|반백택|사토리|오니|텐구|구문지|누에|황혼의괴물|신령|반신|사신|선인|강시|둔갑너구리|츠쿠모가미|인어|목분리|늑대인간)( == 1)?'
  replace   : "$1.race == Race::$2"

- regex     : '\bTALENT:(\w+):(소인|작은체형|거구)'
  replace   : "$1.body_size == BodySize::$2"

- regex     : '\bTALENT:(\w+):(\w+) == 0'
  replace   : "!$1.talent[Talent::$2]"

- regex     : '\bTALENT:(\w+):(\w+)( == 1)?'
  replace   : "$1.talent[Talent::$2]"

- regex     : ' *STAIN:(\w+):(\w+) \|= 2\n *STAIN:(\w+):(\w+) \|= 4'
  replace   : "apply_tentacle_stain($1, Stain::$2);"

- regex     : ' *STAIN:(\w+):(\w+) \|= STAIN:(\w+):(\w+)\n *STAIN:(\w+):(\w+) \|= STAIN:(\w+):(\w+)'
  replace   : "combine_stain_with($1, Stain::$2, $3, Stain::$4);"

- regex     : '\bSTAIN:(\w+):(\w+) != (\d+)'
  replace   : "$1.stain[Stain::$2].is_disjoint(to_stain($3))"

- regex     : '\bSTAIN:(\w+):(\w+) (>?=|&) (\d+)'
  replace   : "$1.stain[Stain::$2].is_superset(to_stain($4))"

- regex     : '\bSTAIN:(\w+):(\w+) ([\|&\+\-\^]?=) (\d+)'
  replace   : "$1.stain[Stain::$2] $3 to_stain($4);"
- regex     : '\bSOURCE:(\w+):(\w+) *([\+\*\-/%]?=) SOURCE(\w+):(\w+)'
  replace   : "$1.source[Source::$2] $3 $4.source[Source::$5];"

- regex     : '\bTIMES (\w+)\.source\[Source::(\w+)\] *, *(\d+).(\d+)'
  replace   : "times_source($1, Source::$2, $3$4);"

- regex     : "[^ ]+? [\\+\\-\\*/]?= .+"
  replace   : "$0;"
